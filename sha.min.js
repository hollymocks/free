class Sha1 { static hash(b, t) { let r = Object.assign({ msgFormat: "string", outFormat: "hex" }, t); switch (r.msgFormat) { default: case "string": b = function (a) { try { return new TextEncoder().encode(a, "utf-8").reduce((a, b) => a + String.fromCharCode(b), "") } catch (b) { return unescape(encodeURIComponent(a)) } }(b); break; case "hex-bytes": b = function (b) { let a = b.replace(" ", ""); return "" == a ? "" : a.match(/.{2}/g).map(a => String.fromCharCode(parseInt(a, 16))).join("") }(b) }let u = [1518500249, 1859775393, 2400959708, 3395469782], a = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]; b += "\x80"; let v = b.length / 4 + 2, d = Math.ceil(v / 16), e = new Array(d); for (let c = 0; c < d; c++) { e[c] = new Array(16); for (let f = 0; f < 16; f++)e[c][f] = b.charCodeAt(64 * c + 4 * f + 0) << 24 | b.charCodeAt(64 * c + 4 * f + 1) << 16 | b.charCodeAt(64 * c + 4 * f + 2) << 8 | b.charCodeAt(64 * c + 4 * f + 3) << 0 } e[d - 1][14] = (b.length - 1) * 8 / 4294967296, e[d - 1][14] = Math.floor(e[d - 1][14]), e[d - 1][15] = (b.length - 1) * 8 & 4294967295; for (let p = 0; p < d; p++) { let g = new Array(80); for (let i = 0; i < 16; i++)g[i] = e[p][i]; for (let h = 16; h < 80; h++)g[h] = Sha1.ROTL(g[h - 3] ^ g[h - 8] ^ g[h - 14] ^ g[h - 16], 1); let j = a[0], k = a[1], l = a[2], m = a[3], q = a[4]; for (let n = 0; n < 80; n++) { let s = Math.floor(n / 20), w = Sha1.ROTL(j, 5) + Sha1.f(s, k, l, m) + q + u[s] + g[n] >>> 0; q = m, m = l, l = Sha1.ROTL(k, 30) >>> 0, k = j, j = w } a[0] = a[0] + j >>> 0, a[1] = a[1] + k >>> 0, a[2] = a[2] + l >>> 0, a[3] = a[3] + m >>> 0, a[4] = a[4] + q >>> 0 } for (let o = 0; o < a.length; o++)a[o] = ("00000000" + a[o].toString(16)).slice(-8); let x = "hex-w" == r.outFormat ? " " : ""; return a.join(x) } static f(d, a, b, c) { switch (d) { case 0: return a & b ^ ~a & c; case 1: case 3: return a ^ b ^ c; case 2: return a & b ^ a & c ^ b & c } } static ROTL(a, b) { return a << b | a >>> 32 - b } }